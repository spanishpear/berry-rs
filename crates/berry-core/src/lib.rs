pub use crate::ident::Descriptor;
pub use crate::ident::Ident;
pub use crate::lockfile::Lockfile;
pub use crate::package::Package;
pub use crate::package::LinkType;

pub mod ident;
pub mod lockfile;
mod locator;
mod metadata;
pub mod package;
pub mod parse;

#[cfg(test)]
mod snapshot_tests {
    use crate::parse::parse_lockfile;

    #[test]
    fn test_entry_with_dependencies_block() {
        let content = r#"# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: 6
  cacheKey: 8

"debug@npm:4.3.4":
  version: 4.3.4
  resolution: "debug@npm:4.3.4"
  dependencies:
    ms: 2.1.2
  languageName: node
  linkType: hard

"ms@npm:2.1.2":
  version: 2.1.2
  resolution: "ms@npm:2.1.2"
  languageName: node
  linkType: hard
"#;

        match parse_lockfile(content) {
            Ok((remaining, lockfile)) => {
                assert_eq!(lockfile.entries.len(), 2, "Should parse 2 entries");
                
                // First entry should have dependencies
                let entry1 = &lockfile.entries[0];
                assert_eq!(entry1.descriptors.len(), 1);
                assert!(!entry1.package.dependencies.is_empty(), "debug should have dependencies");
                assert_eq!(entry1.package.dependencies.len(), 1, "debug should have 1 dependency");
                
                // Second entry should have no dependencies
                let entry2 = &lockfile.entries[1];
                assert_eq!(entry2.descriptors.len(), 1);
                assert!(entry2.package.dependencies.is_empty());
                
                // Remaining should be empty or just whitespace
                assert!(remaining.trim().is_empty(), "Should consume entire file");
            }
            Err(e) => {
                panic!("Parse failed: {e:?}");
            }
        }
    }

    #[test]
    fn test_entry_with_peer_dependencies() {
        let content = r#"# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: 6
  cacheKey: 8

"@testing-library/react@npm:13.4.0":
  version: 13.4.0
  resolution: "@testing-library/react@npm:13.4.0"
  peerDependencies:
    react: "^16.8.0 || ^17.0.0 || ^18.0.0"
    "react-dom": "^16.8.0 || ^17.0.0 || ^18.0.0"
  languageName: node
  linkType: hard

"react@npm:18.2.0":
  version: 18.2.0
  resolution: "react@npm:18.2.0"
  languageName: node
  linkType: hard
"#;

        match parse_lockfile(content) {
            Ok((remaining, lockfile)) => {
                assert_eq!(lockfile.entries.len(), 2, "Should parse 2 entries");
                
                // First entry should have peerDependencies
                let entry1 = &lockfile.entries[0];
                assert_eq!(entry1.descriptors.len(), 1);
                assert!(!entry1.package.peer_dependencies.is_empty());
                assert_eq!(entry1.package.peer_dependencies.len(), 2, "Should have 2 peerDependencies");
                
                // Second entry should have no peerDependencies
                let entry2 = &lockfile.entries[1];
                assert!(entry2.package.peer_dependencies.is_empty());
                
                assert!(remaining.trim().is_empty());
            }
            Err(e) => {
                panic!("Parse failed: {e:?}");
            }
        }
    }

    #[test]
    fn test_multiple_entries_with_dependencies() {
        // This test simulates the issue where entries after one with dependencies fail to parse
        let content = r#"# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: 6
  cacheKey: 8

"@adminhub/verify-domain@workspace:^, @adminhub/verify-domain@workspace:adminhub/packages/common/verify-domain":
  version: 0.0.0-use.local
  resolution: "@adminhub/verify-domain@workspace:adminhub/packages/common/verify-domain"
  dependencies:
    "@adminhub/configuration-card": "workspace:^"
    "@adminhub/domain-claim": "workspace:^"
  languageName: unknown
  linkType: soft

"@adobe/css-tools@npm:^4.0.1, @adobe/css-tools@npm:^4.4.0":
  version: 4.4.0
  resolution: "@adobe/css-tools@npm:4.4.0"
  languageName: node
  linkType: hard

"@airbnb/node-memwatch@npm:^3.0.0":
  version: 3.0.0
  resolution: "@airbnb/node-memwatch@npm:3.0.0"
  languageName: node
  linkType: hard
"#;

        match parse_lockfile(content) {
            Ok((remaining, lockfile)) => {
                assert_eq!(lockfile.entries.len(), 3, "Should parse all 3 entries, not stop after first");
                
                // First entry has dependencies
                assert!(!lockfile.entries[0].package.dependencies.is_empty());
                
                // Second entry should parse even though previous had dependencies
                assert_eq!(lockfile.entries[1].descriptors.len(), 2, "Should have 2 descriptors");
                
                // Third entry should also parse
                assert_eq!(lockfile.entries[2].descriptors.len(), 1);
                
                assert!(remaining.trim().is_empty());
            }
            Err(e) => {
                panic!("Parse failed: {e:?}");
            }
        }
    }

    #[test]
    fn test_entry_with_bin_block() {
        let content = r#"# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: 6
  cacheKey: 8

"eslint@npm:8.0.0":
  version: 8.0.0
  resolution: "eslint@npm:8.0.0"
  bin:
    eslint: bin/eslint.js
  languageName: node
  linkType: hard

"next-package@npm:1.0.0":
  version: 1.0.0
  resolution: "next-package@npm:1.0.0"
  languageName: node
  linkType: hard
"#;

        match parse_lockfile(content) {
            Ok((remaining, lockfile)) => {
                assert_eq!(lockfile.entries.len(), 2, "Should parse both entries");
                
                // First entry has bin
                assert!(!lockfile.entries[0].package.bin.is_empty());
                
                // Second entry should parse correctly
                assert_eq!(lockfile.entries[1].descriptors.len(), 1);
                
                assert!(remaining.trim().is_empty());
            }
            Err(e) => {
                panic!("Parse failed: {e:?}");
            }
        }
    }
}
