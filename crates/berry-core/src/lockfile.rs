use crate::ident::Descriptor;
use crate::package::Package;
use nom::{
  IResult, Parser,
  bytes::complete::{is_not, tag, take_while, take_while1},
  character::complete::{char, newline, space1},
  combinator::opt,
  multi::fold_many0,
  sequence::{pair, preceded, separated_pair, terminated},
};
use smallvec::SmallVec;

/// A serialized representation of a yarn lockfile.
/// Uses borrowed strings for zero-copy parsing.
#[derive(Debug)]
pub struct Lockfile<'a> {
  /// Lockfile version and cache key
  pub metadata: Metadata<'a>,
  /// The entries in the lockfile
  pub entries: Vec<Entry<'a>>,
  /// Optional resolutions section (key -> value)
  pub resolutions: Option<Vec<(&'a str, &'a str)>>,
  /// Optional constraints section (key -> value)
  pub constraints: Option<Vec<(&'a str, &'a str)>>,
}

/// A single lockfile entry is a mapping of one or more descriptors to a single package
#[derive(Debug)]
pub struct Entry<'a> {
  /// The descriptors of the entry (using `SmallVec` for stack allocation in common case)
  pub descriptors: SmallVec<[Descriptor<'a>; 4]>,
  /// The package of the entry
  pub package: Package<'a>,
}

impl<'a> Entry<'a> {
  pub fn new(descriptors: SmallVec<[Descriptor<'a>; 4]>, package: Package<'a>) -> Self {
    Self {
      descriptors,
      package,
    }
  }
}

/// The start of the metadata block
/// Typically at the start of the file
///
/// # Examples
///
/// ```text
/// __metadata:
///   version: 8
///   cacheKey: 9
/// ```
///
/// will often be represented as:
///
/// ```text
/// Metadata {
///   version: "8",
///   cache_key: "9",
/// }
/// ```
#[derive(Debug)]
pub struct Metadata<'a> {
  /// The version of the lockfile
  pub version: &'a str,
  /// The cache key of the lockfile
  pub cache_key: &'a str,
}

impl<'a> Metadata<'a> {
  /// Create a new Metadata from a version and a cache key (borrowed)
  pub const fn new(version: &'a str, cache_key: &'a str) -> Self {
    Self { version, cache_key }
  }
}

/// A line of metadata is a key-value pair, with a space-based indent
/// e.g. `  version: 8`
pub(crate) fn parse_metadata_line(input: &str) -> IResult<&str, (&str, &str)> {
  terminated(
    preceded(
      space1,
      separated_pair(
        take_while(|c: char| c.is_alphabetic() || c == '_'),
        pair(char(':'), space1),
        is_not("\r\n"),
      ),
    ),
    newline,
  )
  .parse(input)
}

/// Parses the __metadata block of a yarn lockfile
///
/// # Examples
///
/// ```text
/// __metadata:
///   version: 8
///   cacheKey: 9
/// ```
pub(crate) fn parse_metadata(input: &str) -> IResult<&str, Metadata<'_>> {
  let (rest, _) = terminated(tag("__metadata:"), newline).parse(input)?;
  let (rest, version_line) = parse_metadata_line(rest)?;
  let (rest, cache_key_line) = parse_metadata_line(rest)?;

  // Trim quotes from values (returns slices into the input)
  let version = version_line.1.trim_matches('"');
  let cache_key = cache_key_line.1.trim_matches('"');

  Ok((rest, Metadata::new(version, cache_key)))
}

// NOTE: A faster approach **could** be to just consume three lines, and not even use nom
/// Parse a yarn lockfile header
/// It matches explicitly the yarn lockfile header comments
/// and the newline that follows
///
pub(crate) fn parse_yarn_header(input: &str) -> IResult<&str, (&str, &str)> {
  terminated(
    pair(
      terminated(
        tag("# This file is generated by running \"yarn install\" inside your project."),
        newline,
      ),
      terminated(
        tag("# Manual changes might be lost - proceed with caution!"),
        newline,
      ),
    ),
    newline,
  )
  .parse(input)
}

/// Parse a single top-level key-value line indented with two spaces: `  key: value`.
fn parse_top_kv_line(input: &str) -> IResult<&str, (&str, &str)> {
  let (rest, (_, key, _, _, val, _)) = (
    tag("  "),
    take_while1(|c: char| c != ':' && c != '\n' && c != '\r'),
    char(':'),
    space1,
    is_not("\r\n"),
    opt(newline),
  )
    .parse(input)?;

  Ok((rest, (key, val)))
}

/// Parse a top-level block like:
/// resolutions:\n
///   foo@^1: npm:1.2.3\n
fn parse_top_level_kv_block<'a>(
  header: &'static str,
) -> impl Fn(&'a str) -> IResult<&'a str, Vec<(&'a str, &'a str)>> {
  move |input: &str| {
    let (rest, (_, _, entries)) = (
      tag(header),
      newline,
      fold_many0(parse_top_kv_line, Vec::new, |mut acc, item| {
        acc.push(item);
        acc
      }),
    )
      .parse(input)?;

    Ok((rest, entries))
  }
}

/// Parse resolutions block, returning borrowed strings
pub(crate) fn parse_resolutions(input: &str) -> IResult<&str, Vec<(&str, &str)>> {
  let (rest, entries) = parse_top_level_kv_block("resolutions:")(input)?;
  // Trim quotes but keep as borrowed slices
  let trimmed: Vec<(&str, &str)> = entries
    .into_iter()
    .map(|(k, v)| (k.trim_matches('"').trim(), v.trim_matches('"')))
    .collect();
  Ok((rest, trimmed))
}

/// Parse constraints block, returning borrowed strings
pub(crate) fn parse_constraints(input: &str) -> IResult<&str, Vec<(&str, &str)>> {
  let (rest, entries) = parse_top_level_kv_block("constraints:")(input)?;
  // Trim but keep as borrowed slices
  let trimmed: Vec<(&str, &str)> = entries
    .into_iter()
    .map(|(k, v)| (k.trim(), v.trim_matches('"')))
    .collect();
  Ok((rest, trimmed))
}

#[cfg(test)]
mod tests_parse_r_c {
  use super::*;

  #[test]
  fn test_parse_top_level_resolutions_block() {
    let input = r#"resolutions:
  lodash@^4.0.0: npm:4.17.21
  "@scope/pkg@^1": "npm:^1.2.3"
"#;
    let (rest, resolutions) = parse_resolutions(input).expect("parse resolutions");
    assert!(rest.is_empty());
    assert_eq!(resolutions.len(), 2);
    assert_eq!(resolutions[0].0, "lodash@^4.0.0");
    assert_eq!(resolutions[0].1, "npm:4.17.21");
    assert_eq!(resolutions[1].0, "@scope/pkg@^1");
    assert_eq!(resolutions[1].1, "npm:^1.2.3");
  }

  #[test]
  fn test_parse_top_level_constraints_block() {
    let input = r"constraints:
  react@^18: npm:^18.2.0
";
    let (rest, constraints) = parse_constraints(input).expect("parse constraints");
    assert!(rest.is_empty());
    assert_eq!(constraints.len(), 1);
    assert_eq!(constraints[0].0, "react@^18");
    assert_eq!(constraints[0].1, "npm:^18.2.0");
  }
}

#[cfg(test)]
mod tests_header_meta {
  use super::*;
  use nom::{
    AsChar, Parser, bytes::complete::take_while, character::complete::newline, sequence::terminated,
  };

  /// Helper combinator to take an entire line, including the newline character
  fn take_whole_line(input: &str) -> IResult<&str, &str> {
    terminated(take_while(|c| !AsChar::is_newline(c)), newline).parse(input)
  }

  #[test]
  fn test_parse_lockfile_header() {
    let file_contents = include_str!("../../../fixtures/berry.lock");
    let result = parse_yarn_header(file_contents);
    assert!(result.is_ok());
    let (leftover, (l1, l2)) = result.unwrap();

    // we have eaten the extra newline at the end of the header
    assert_ne!(leftover, "\n");

    // confirm we have the right lines
    assert_eq!(
      l1,
      "# This file is generated by running \"yarn install\" inside your project."
    );
    assert_eq!(l2, "# Manual changes might be lost - proceed with caution!");

    // make sure leftover doesn't include the header
    assert!(
      !leftover
        .contains("# This file is generated by running \"yarn install\" inside your project.")
    );
    assert!(!leftover.contains("# Manual changes might be lost - proceed with caution!"));

    // confirm the cursor is now at metadata
    // such that we are sure we have eaten the newline
    let (_, next) = take_whole_line(leftover).unwrap();
    assert_eq!(next, "__metadata:");
  }

  #[test]
  fn test_parse_take_until_eol() {
    let input = "hello world\n";
    let result = take_whole_line(input);
    let (leftover, consumed) = result.unwrap();
    assert_eq!(leftover, "");
    assert_eq!(consumed, "hello world");
  }

  #[test]
  fn test_parse_metadata() {
    let metadata_block = r#"__metadata:
  version: "8"
  cacheKey: "9"

"#;
    let result = parse_metadata(metadata_block);
    assert!(result.is_ok());

    let (rest, metadata) = result.unwrap();
    assert_eq!(rest, "\n");
    assert_eq!(metadata.version, "8");
    assert_eq!(metadata.cache_key, "9");
  }
}
